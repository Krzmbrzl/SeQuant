#include <SeQuant/domain/utils/eval_sequence.hpp>
#include <iostream>
#include <sstream>
#include <unordered_set>

#include "catch.hpp"

template <typename T>
void print_inorder(const std::unique_ptr<T>& node) {
  assert(node);
  if (node->leaf()) {
    std::cout << node->data();
    return;
  }
  print_inorder(node->left());
  std::cout << " " << node->data() << " ";
  print_inorder(node->right());
}

TEST_CASE("TEST_EVAL_SEQUENCE", "[eval_sequence]") {
  using namespace sequant::utils;
  auto init_rt_vec = [](size_t n) {
    std::vector<eval_sequence<size_t>> vec;
    vec.reserve(n);
    for (size_t ii = 0; ii < n; ++ii)
      vec.emplace_back(eval_sequence<size_t>{ii});
    return vec;
  };

  SECTION("eval_sequence") {
    REQUIRE_NOTHROW(eval_sequence{0});
    REQUIRE(eval_sequence{0}.terminal());
    REQUIRE(eval_sequence{0}.label() == 0);

    auto t0 = eval_sequence{0};
    REQUIRE_NOTHROW(t0.seque(eval_sequence{1}));

    t0.seque(eval_sequence{2});
    t0.seque(eval_sequence{3});

    REQUIRE_NOTHROW(eval_sequence{0, {1, 2, 3}});
  }

  SECTION("enumerate_eval_sequence") {
    //
    // Return a lambda expression that can be passed to the
    // enumerate_eval_sequence function.
    // The lambda will insert the string representations of
    // eval sequence trees generated by the enumerate_eval_sequence function
    // to to_container
    //
    auto reap_seqs_to = [](std::unordered_set<std::string>& to_container) {
      return [&to_container](const eval_sequence<size_t>& t) -> void {
        std::ostringstream oss;
        oss << t;
        oss.flush();
        auto result = to_container.insert(oss.str());
        // assert the same sequence was not inserted previously
        assert(result.second);
      };
    };

    std::unordered_set<std::string> result1;

    enumerate_eval_sequence(init_rt_vec(3), reap_seqs_to(result1));
    REQUIRE(result1 == std::unordered_set<std::string>{
                           "(0 1 2)",  //
                           "(0 2 1)",  //
                           "(1 2 0)"   //
                       });

    std::unordered_set<std::string> result2;
    enumerate_eval_sequence(init_rt_vec(4), reap_seqs_to(result2));
    REQUIRE(result2 == std::unordered_set<std::string>{
                           "(0 1 2 3)",    //
                           "(0 1 3 2)",    //
                           "(0 2 1 3)",    //
                           "(0 2 3 1)",    //
                           "(0 3 1 2)",    //
                           "(0 3 2 1)",    //
                           "(1 2 0 3)",    //
                           "(1 2 3 0)",    //
                           "(0 3 (1 2))",  //
                           "(1 3 0 2)",    //
                           "(1 3 2 0)",    //
                           "(0 2 (1 3))",  //
                           "(2 3 0 1)",    //
                           "(2 3 1 0)",    //
                           "(0 1 (2 3))",  //
                       });

    //
    // In mathematics, the double factorial or semifactorial of a number n,
    // denoted by n!!, is the product of all the integers from 1 up to n that
    // have the same parity (odd or even) as n. -- wikipedia.org

    auto double_factorial = [](size_t x) {
      if (x == 0) return 1;
      long long n = x;
      auto result = 1;
      if (n % 2 == 0) {
        // even
        for (; n >= 2; n -= 2) result *= n;
      } else {
        // odd
        for (; n >= 1; n -= 2) result *= n;
      }
      return result;
    };

    //
    // counts the number of trees enumerated by the
    // enumerate_eval_sequence function for a given initial vector of
    // rooted trees init
    //
    auto count_num_eval_seqs =
        [](const std::vector<eval_sequence<size_t>>& init) {
          size_t count = 0;
          enumerate_eval_sequence(
              init, std::function(
                        [&count](const eval_sequence<size_t>&) { ++count; }));
          return count;
        };

    // clang-format off
    // the number of ways to evaluate a tensor product depends on the number
    // of factors it has -- obviously
    // the growth follows the odd factorial sequence
    // ie.
    // # factors in a product | # ways to evaluate product
    // -----------------------|---------------------------
    //                     2  | 1     = 1!!
    //                     3  | 3     = 3!!
    //                     4  | 15    = 5!!
    //                     5  | 105   = 7!!
    //                     6  | 945   = 9!!
    //
    // and so on.
    // clang-format on

    auto iter = 0;
    size_t numFacs = 2, oddFacInp = 1;
    // increasing the iter boundary exponentially increases comp time
    while (iter < 7) {
      REQUIRE(count_num_eval_seqs(init_rt_vec(numFacs)) ==
              double_factorial(oddFacInp));
      ++numFacs;
      oddFacInp += 2;
      ++iter;
    }

  }  // SECTION

  SECTION("binarize_eval_sequence") {
    struct {
      int operator()(short x) { return x; }
      int operator()(int x, int y) { return (x + y) * 2; }
    } sum_and_double;

    auto nseq = eval_sequence<short>{2, {3, 5, 7}};
    auto nbinarized = binarize_eval_sequence<short, int>(nseq, sum_and_double);
    // clang-format off
    // nbinarized tree:
    //           74
    //          /  \
    //       30    7
    //      /  \
    //   10     5
    //   / \
    // 2   3
    // clang-format on

    auto expected_node1 = make_binary_expr<int>(
        74,
        make_binary_expr<int>(30, make_binary_expr<int>(10, 2, 3),
                              make_binary_expr<int>(5)),
        make_binary_expr<int>(7));

    REQUIRE(*nbinarized == *expected_node1);

    struct {
      size_t operator()(std::string_view s) const { return s.size(); }
      size_t operator()(size_t x, size_t y) const { return x + y; }
    } str_len;

    auto sseq = eval_sequence<std::string_view>{"Foo", {"Bar", "Bazz"}};

    auto sbinarized =
        binarize_eval_sequence<std::string_view, size_t>(sseq, str_len);
    // clang-format off
    // sbinarized tree:
    //              10
    //            /   \
    //          6      4
    //        /  \
    //      3     3
    // clang-format on

    auto expected_node2 =
        make_binary_expr<size_t>(10,                                 //
                                 make_binary_expr<size_t>(6, 3, 3),  //
                                 make_binary_expr<size_t>(4));       //

    REQUIRE(*sbinarized == *expected_node2);

    // print_inorder(std::move(sbinarized));
    // std::cout << std::endl;
  }
}
