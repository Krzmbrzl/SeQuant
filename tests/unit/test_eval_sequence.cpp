#include <SeQuant/domain/utils/eval_sequence.hpp>
#include <iostream>
#include <sstream>
#include <unordered_set>

#include "catch.hpp"

template <typename T>
void print_inorder(const std::unique_ptr<T>& node) {
  assert(node);
  if (node->leaf()) {
    std::cout << node->data();
    return;
  }
  print_inorder(node->left());
  std::cout << " " << node->data() << " ";
  print_inorder(node->right());
}

TEST_CASE("TEST_EVAL_SEQUENCE", "[eval_sequence]") {
  using namespace sequant::utils;
  auto init_rt_vec = [](size_t n) {
    std::vector<eval_sequence<size_t>> vec;
    vec.reserve(n);
    for (size_t ii = 0; ii < n; ++ii)
      vec.emplace_back(eval_sequence<size_t>{ii});
    return vec;
  };

  SECTION("eval_sequence") {
    REQUIRE_NOTHROW(eval_sequence{0});
    REQUIRE(eval_sequence{0}.terminal());
    REQUIRE(eval_sequence{0}.label() == 0);

    auto t0 = eval_sequence{0};
    REQUIRE_NOTHROW(t0.seque(eval_sequence{1}));

    t0.seque(eval_sequence{2});
    t0.seque(eval_sequence{3});

    REQUIRE_NOTHROW(eval_sequence{0, {1, 2, 3}});
  }

  SECTION("enumerate_eval_sequence") {
    //
    // Return a lambda expression that can be passed to the
    // enumerate_eval_sequence function.
    // The lambda will insert the string representations of
    // eval sequence trees generated by the enumerate_eval_sequence function
    // to to_container
    //
    auto reap_seqs_to = [](std::unordered_set<std::string>& to_container) {
      return [&to_container](const eval_sequence<size_t>& t) -> void {
        std::ostringstream oss;
        oss << t;
        oss.flush();
        auto result = to_container.insert(oss.str());
        // assert the same sequence was not inserted previously
        assert(result.second);
      };
    };

    std::unordered_set<std::string> result1;

    enumerate_eval_sequence(init_rt_vec(3), reap_seqs_to(result1));
    REQUIRE(result1 == std::unordered_set<std::string>{
                           "(0 1 2)",  //
                           "(0 2 1)",  //
                           "(1 2 0)"   //
                       });

    std::unordered_set<std::string> result2;
    enumerate_eval_sequence(init_rt_vec(4), reap_seqs_to(result2));
    REQUIRE(result2 == std::unordered_set<std::string>{
                           "(0 1 2 3)",    //
                           "(0 1 3 2)",    //
                           "(0 2 1 3)",    //
                           "(0 2 3 1)",    //
                           "(0 3 1 2)",    //
                           "(0 3 2 1)",    //
                           "(1 2 0 3)",    //
                           "(1 2 3 0)",    //
                           "(0 3 (1 2))",  //
                           "(1 3 0 2)",    //
                           "(1 3 2 0)",    //
                           "(0 2 (1 3))",  //
                           "(2 3 0 1)",    //
                           "(2 3 1 0)",    //
                           "(0 1 (2 3))",  //
                       });

    //
    // In mathematics, the double factorial or semifactorial of a number n,
    // denoted by n!!, is the product of all the integers from 1 up to n that
    // have the same parity (odd or even) as n. -- wikipedia.org

    auto double_factorial = [](size_t x) {
      if (x == 0) return 1;
      long long n = x;
      auto result = 1;
      if (n % 2 == 0) {
        // even
        for (; n >= 2; n -= 2) result *= n;
      } else {
        // odd
        for (; n >= 1; n -= 2) result *= n;
      }
      return result;
    };

    //
    // counts the number of trees enumerated by the
    // enumerate_eval_sequence function for a given initial vector of
    // rooted trees init
    //
    auto count_num_eval_seqs =
        [](const std::vector<eval_sequence<size_t>>& init) {
          size_t count = 0;
          enumerate_eval_sequence(
              init, std::function(
                        [&count](const eval_sequence<size_t>&) { ++count; }));
          return count;
        };

    // clang-format off
        // the number of ways to evaluate a tensor product depends on the number
        // of factors it has -- obviously
        // the growth follows the odd factorial sequence
        // ie.
        // # factors in a product | # ways to evaluate product
        // -----------------------|---------------------------
        //                     2  | 1     = 1!!
        //                     3  | 3     = 3!!
        //                     4  | 15    = 5!!
        //                     5  | 105   = 7!!
        //                     6  | 945   = 9!!
        //
        // and so on.
    // clang-format on

    auto iter = 0;
    size_t numFacs = 2, oddFacInp = 1;
    // increasing the iter boundary exponentially increases comp time
    while (iter < 7) {
      REQUIRE(count_num_eval_seqs(init_rt_vec(numFacs)) ==
              double_factorial(oddFacInp));
      ++numFacs;
      oddFacInp += 2;
      ++iter;
    }

  }  // SECTION

  SECTION("binarize_eval_sequence") {
    struct {
      int operator()(short x) const { return x; }
      int operator()(int x, int y) const { return (x + y) * 2; }
    } sum_and_double;

    auto nseq = eval_sequence<short>{2, {3, 5, 7}};
    auto nbinarized = binarize_eval_sequence<short>(nseq, sum_and_double);
    // clang-format off
        // nbinarized tree:
        //           74
        //          /  \
        //       30    7
        //      /  \
        //   10     5
        //   / \
        // 2   3
    // clang-format on

    auto expected_node0 = make_binary_expr<int>(
        74,
        make_binary_expr<int>(30, make_binary_expr<int>(10, 2, 3),
                              make_binary_expr<int>(5)),
        make_binary_expr<int>(7));

    REQUIRE(*nbinarized == *expected_node0);

    struct {
      size_t operator()(std::string_view s) const { return s.size(); }
      size_t operator()(size_t x, size_t y) const { return x + y; }
    } str_len;

    auto sseq1 = eval_sequence<std::string_view>{"Foo", {"Bar", "Bazz"}};

    auto sbinarized1 = binarize_eval_sequence<std::string_view>(sseq1, str_len);
    // clang-format off
        // sbinarized tree:
        //              10
        //            /   \
        //          6      4
        //        /  \
        //      3     3
    // clang-format on

    auto expected_node1 =
        make_binary_expr<size_t>(10,                                 //
                                 make_binary_expr<size_t>(6, 3, 3),  //
                                 make_binary_expr<size_t>(4));       //

    REQUIRE(*sbinarized1 == *expected_node1);

    using str_seq = eval_sequence<std::string_view>;

    auto sseq2 = str_seq{
        "Foo", {str_seq{"Bar"}, str_seq{"Spam", {"Egg"}}, str_seq{"Bazz"}}};

    auto sbinarized2 = binarize_eval_sequence<std::string_view>(sseq2, str_len);

    // clang-format off
    //
    //                       17
    //                     /    \
    //                    /      \
    //                   /        \
    //                  /          \
    //                 /            \
    //               13               4 (Bazz)
    //              /   \
    //             /      \
    //            /         \
    //           /            \
    //          /               \
    //         6                  7
    //        /  \               /  \
    //       /    \             /     \
    //   3 (Foo)  3 (Bar)    4 (Spam)   3 (Egg)
    //
    // clang-format on

    auto expected_node2 = make_binary_expr<size_t>(
        17,
        make_binary_expr<size_t>(
            13,
            make_binary_expr<size_t>(6, make_binary_expr<size_t>(3),
                                     make_binary_expr<size_t>(3)),
            make_binary_expr<size_t>(7, make_binary_expr<size_t>(4),
                                     make_binary_expr<size_t>(3))),
        make_binary_expr<size_t>(4));

    REQUIRE(*expected_node2 == *sbinarized2);
  }

  SECTION("transform_eval_sequence") {
    using seq_t = eval_sequence<size_t>;

    auto square = [](size_t x) { return x * x; };
    auto cube = [](size_t x) { return x * x * x; };

    auto seq1 = seq_t{1, {2, 3, 5, 7}};

    auto tr1 = transform_eval_sequence<size_t>(seq1, square);

    REQUIRE(tr1 == seq_t{1, {4, 9, 25, 49}});

    auto seq2 = seq_t{1, {seq_t{2, {3}}, seq_t{5, {7}}}};
    // seq2 = (1, (2, 3), (5, 7))

    auto tr2 = transform_eval_sequence<size_t>(seq2, cube);

    REQUIRE(tr2 == seq_t{1, {seq_t{8, {27}}, seq_t{125, {7 * 7 * 7}}}});
  }
}
