#include <SeQuant/domain/utils/eval_seq.hpp>
#include <sstream>
#include <unordered_set>

#include "catch.hpp"

template <typename T, typename Os>
Os& operator<<(Os& os, const sequant::utils::eval_seq<T>& seq) {
  if (seq.terminal()) {
    os << seq.label();
    return os;
  }
  os << "(" << seq.label() << " ";

  for (auto ii = 0; ii < seq.nodes().size() - 1; ++ii)
    os << seq.nodes()[ii] << " ";
  os << *(seq.nodes().end() - 1);

  os << ")";
  return os;
}

TEST_CASE("TEST_EVAL_SEQUENCE", "[eval_seq]") {
  using namespace sequant::utils;
  auto init_rt_vec = [](size_t n) {
    std::vector<eval_seq<size_t>> vec;
    vec.reserve(n);
    for (size_t ii = 0; ii < n; ++ii) vec.emplace_back(eval_seq<size_t>{ii});
    return vec;
  };

  SECTION("eval_seq") {
    REQUIRE_NOTHROW(eval_seq{0});
    REQUIRE(eval_seq{0}.terminal());
    REQUIRE(eval_seq{0}.label() == 0);

    auto t0 = eval_seq{0};
    REQUIRE_NOTHROW(t0.seque(eval_seq{1}));

    t0.seque(eval_seq{2});
    t0.seque(eval_seq{3});

    REQUIRE_NOTHROW(eval_seq{0, {1, 2, 3}});
  }

  SECTION("binarize") {
    struct {
      int operator()(short x) const { return x; }
      int operator()(int x, int y) const { return (x + y) * 2; }
    } sum_and_double;

    auto const nseq = eval_seq<short>{2, {3, 5, 7}};
    auto const nbinarized = nseq.binarize(sum_and_double);
    // clang-format off
        // nbinarized tree:
        //           74
        //          /  \
        //       30    7
        //      /  \
        //   10     5
        //   / \
        // 2   3
    // clang-format on

    auto const expected_node0 = binary_node<int>{
        74,
        binary_node<int>{30, binary_node<int>{10, 2, 3}, binary_node<int>{5}},
        binary_node<int>{7}};

    REQUIRE(*nbinarized == *expected_node0);

    struct {
      size_t operator()(std::string_view s) const { return s.size(); }
      size_t operator()(size_t x, size_t y) const { return x + y; }
    } str_len;

    auto const sseq1 = eval_seq<std::string_view>{"Foo", {"Bar", "Bazz"}};

    auto const sbinarized1 = sseq1.binarize(str_len);
    // clang-format off
        // sbinarized tree:
        //              10
        //            /   \
        //          6      4
        //        /  \
        //      3     3
    // clang-format on

    auto const expected_node1 =
        binary_node<size_t>{10,                            //
                            binary_node<size_t>{6, 3, 3},  //
                            binary_node<size_t>{4}};       //

    REQUIRE(*sbinarized1 == *expected_node1);

    using str_seq = eval_seq<std::string_view>;

    auto const sseq2 = str_seq{
        "Foo", {str_seq{"Bar"}, str_seq{"Spam", {"Egg"}}, str_seq{"Bazz"}}};

    auto const sbinarized2 = sseq2.binarize(str_len);

    // clang-format off
    //
    //                       17
    //                     /    \
    //                    /      \
    //                   /        \
    //                  /          \
    //                 /            \
    //               13               4 (Bazz)
    //              /   \
    //             /      \
    //            /         \
    //           /            \
    //          /               \
    //         6                  7
    //        /  \               /  \
    //       /    \             /     \
    //   3 (Foo)  3 (Bar)    4 (Spam)   3 (Egg)
    //
    // clang-format on

    auto const expected_node2 = binary_node<size_t>{
        17,
        binary_node<size_t>{13,
                            binary_node<size_t>{6, binary_node<size_t>{3},
                                                binary_node<size_t>{3}},
                            binary_node<size_t>{7, binary_node<size_t>{4},
                                                binary_node<size_t>{3}}},
        binary_node<size_t>{4}};

    REQUIRE(*expected_node2 == *sbinarized2);
  }

  SECTION("transform") {
    using seq_t = eval_seq<size_t>;

    auto square = [](size_t x) { return x * x; };
    auto cube = [](size_t x) { return x * x * x; };

    auto const seq1 = seq_t{1, {2, 3, 5, 7}};

    auto const tr1 = seq1.transform(square);

    REQUIRE(tr1 == seq_t{1, {4, 9, 25, 49}});

    auto const seq2 = seq_t{1, {seq_t{2, {3}}, seq_t{5, {7}}}};
    // seq2 = (1, (2, 3), (5, 7))

    auto const tr2 = seq2.transform(cube);

    REQUIRE(tr2 == seq_t{1, {seq_t{8, {27}}, seq_t{125, {7 * 7 * 7}}}});
  }

  SECTION("enumerate_eval_seq") {
    //
    // Return a lambda expression that can be passed to the
    // enumerate_eval_seq function.
    // The lambda will insert the string representations of
    // eval sequence trees generated by the enumerate_eval_seq function
    // to to_container
    //
    auto reap_seqs_to = [](std::unordered_set<std::string>& to_container) {
      return [&to_container](const eval_seq<size_t>& t) -> void {
        std::ostringstream oss;
        oss << t;
        oss.flush();
        auto result = to_container.insert(oss.str());
        // assert the same sequence was not inserted previously
        assert(result.second);
      };
    };

    std::unordered_set<std::string> result1;

    enumerate_eval_seq(init_rt_vec(3), reap_seqs_to(result1));
    REQUIRE(result1 == std::unordered_set<std::string>{
                           "(0 1 2)",  //
                           "(0 2 1)",  //
                           "(1 2 0)"   //
                       });

    std::unordered_set<std::string> result2;
    enumerate_eval_seq(init_rt_vec(4), reap_seqs_to(result2));
    REQUIRE(result2 == std::unordered_set<std::string>{
                           "(0 1 2 3)",    //
                           "(0 1 3 2)",    //
                           "(0 2 1 3)",    //
                           "(0 2 3 1)",    //
                           "(0 3 1 2)",    //
                           "(0 3 2 1)",    //
                           "(1 2 0 3)",    //
                           "(1 2 3 0)",    //
                           "(0 3 (1 2))",  //
                           "(1 3 0 2)",    //
                           "(1 3 2 0)",    //
                           "(0 2 (1 3))",  //
                           "(2 3 0 1)",    //
                           "(2 3 1 0)",    //
                           "(0 1 (2 3))",  //
                       });

    //
    // In mathematics, the double factorial or semifactorial of a number n,
    // denoted by n!!, is the product of all the integers from 1 up to n that
    // have the same parity (odd or even) as n. -- wikipedia.org

    auto double_factorial = [](size_t x) {
      if (x == 0) return 1;
      long long n = x;
      auto result = 1;
      if (n & 0x1) {
        // odd
        for (; n >= 1; n -= 2) result *= n;
      } else {
        // even
        for (; n >= 2; n -= 2) result *= n;
      }
      return result;
    };

    //
    // counts the number of trees enumerated by the
    // enumerate_eval_seq function for a given initial vector of
    // rooted trees init
    //
    auto count_num_eval_seqs = [](const std::vector<eval_seq<size_t>>& init) {
      size_t count = 0;
      enumerate_eval_seq(
          init, std::function([&count](const eval_seq<size_t>&) { ++count; }));
      return count;
    };

    // clang-format off
        // the number of ways to evaluate a tensor product depends on the number
        // of factors it has -- obviously
        // the growth follows the odd factorial sequence
        // ie.
        // # factors in a product | # ways to evaluate product
        // -----------------------|---------------------------
        //                     2  | 1     = 1!!
        //                     3  | 3     = 3!!
        //                     4  | 15    = 5!!
        //                     5  | 105   = 7!!
        //                     6  | 945   = 9!!
        //
        // and so on.
    // clang-format on

    auto iter = 0;
    size_t numFacs = 2, oddFacInp = 1;
    // increasing the iter boundary exponentially increases comp time
    while (iter < 7) {
      REQUIRE(count_num_eval_seqs(init_rt_vec(numFacs)) ==
              double_factorial(oddFacInp));
      ++numFacs;
      oddFacInp += 2;
      ++iter;
    }

  }  // SECTION
}
