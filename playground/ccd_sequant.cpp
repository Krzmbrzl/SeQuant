#include <SeQuant/core/expr.hpp>
#include <SeQuant/core/optimize.hpp>
#include <SeQuant/core/tensor.hpp>
#include <SeQuant/domain/mbpt/convention.hpp>
#include <SeQuant/domain/mbpt/spin.hpp>
#include <SeQuant/domain/mbpt/sr.hpp>

#include <libperm/Cycle.hpp>
#include <libperm/PrimitivePermutationGroup.hpp>
#include <libperm/Utils.hpp>

#include <algorithm>
#include <cassert>
#include <iostream>
#include <memory>
#include <numeric>
#include <set>
#include <string>
#include <unordered_map>

using namespace sequant;
using namespace sequant::mbpt::sr;

struct Idx2Size {
  static const size_t nocc = 10;
  static const size_t nvirt = 100;
  size_t operator()(Index const& idx) const {
    if (idx.space() == IndexSpace::active_occupied)
      return nocc;
    else if (idx.space() == IndexSpace::active_unoccupied)
      return nvirt;
    else
      throw std::runtime_error("Unsupported IndexSpace type encountered");
  }
};

struct BraKetIndices {
  std::vector<Index> bra;
  std::vector<Index> ket;
};

BraKetIndices determine_result_indices(const ExprPtr& expr) {
  if (expr.is<Constant>()) {
    return {};
  } else if (expr.is<Tensor>()) {
    const Tensor& tensor = expr.as<Tensor>();
    return {std::vector<Index>(tensor.bra().begin(), tensor.bra().end()),
            std::vector<Index>(tensor.ket().begin(), tensor.ket().end())};
  } else if (expr.is<Sum>()) {
    // In order for the sum to be valid, all summands must have the same
    // external indices, so it suffices to look only at the first one
    return determine_result_indices(expr.as<Sum>().summand(0));
  } else if (expr.is<Product>()) {
    std::set<Index> braIndices;
    std::set<Index> ketIndices;

    for (const ExprPtr& current : expr.as<Product>()) {
      BraKetIndices indices = determine_result_indices(current);

      braIndices.insert(indices.bra.begin(), indices.bra.end());
      ketIndices.insert(indices.ket.begin(), indices.ket.end());
    }

    BraKetIndices externals;
    std::set_difference(braIndices.begin(), braIndices.end(),
                        ketIndices.begin(), ketIndices.end(),
                        std::back_inserter(externals.bra));
    std::set_difference(ketIndices.begin(), ketIndices.end(),
                        braIndices.begin(), braIndices.end(),
                        std::back_inserter(externals.ket));

    return externals;
  } else {
    throw std::runtime_error("Weird expression type encountered");
  }
}

std::wstring to_itf_tag(const IndexSpace& space) {
  if (space == IndexSpace::active_occupied) {
    return L"c";
  } else if (space == IndexSpace::active_unoccupied) {
    return L"e";
  } else {
    throw std::runtime_error("Unsupported index space");
  }
}

bool isSpacePattern(const std::vector<Index>& indices,
                    const std::vector<IndexSpace::Type>& pattern) {
  assert(indices.size() == pattern.size());

  for (std::size_t i = 0; i < indices.size(); ++i) {
    if (indices.at(i).space().type() != pattern.at(i)) {
      return false;
    }
  }

  return true;
}

// The symmetries of the non-symmetrized two-electron integrals are generated by
// switching the bra and ket orbitals of either particle one or particle two and
// by the typical column-symmetry (particle-1,2-symmetry)
perm::PrimitivePermutationGroup twoElectronSymmetries(
    {perm::ExplicitPermutation(perm::Cycle({0, 2})),
     perm::ExplicitPermutation(perm::Cycle({1, 3})),
     perm::ExplicitPermutation(perm::Cycle({{0, 1}, {2, 3}}))});

Tensor transform_two_electron_ints(const Tensor& tensor) {
  assert(tensor.label() == L"g");

  // The spin-free (skeleton) two-electron integrals retain the full symmetry of
  // the regular (non-antisymmetrized) two-electron integrals We have to use
  // this symmetry to map the integral to either the K or the J integral
  // available in Molpro.
  std::vector<Index> indices(tensor.braket().begin(), tensor.braket().end());
  assert(indices.size() == 4);

  perm::canonicalize(indices, twoElectronSymmetries,
                     [](const Index& idx1, const Index& idx2) {
                       if (idx1.space().type() != idx2.space().type()) {
                         return !(idx1.space().type() < idx2.space().type());
                       } else {
                         // Fall back to regular compare for same-space indices
                         return idx1 < idx2;
                       }
                     });

  constexpr IndexSpace::Type occ = IndexSpace::active_occupied;
  constexpr IndexSpace::Type virt = IndexSpace::active_unoccupied;

  // occ < virt
  static_assert(!(virt < occ));

  if (isSpacePattern(indices, {virt, virt, occ, occ}) ||
      isSpacePattern(indices, {occ, occ, occ, occ}) ||
      isSpacePattern(indices, {virt, virt, virt, virt}) ||
      isSpacePattern(indices, {virt, occ, occ, occ})) {
    // Keep index sequence
    return Tensor(L"K", {indices[0], indices[1]}, {indices[2], indices[3]});
  } else if (isSpacePattern(indices, {virt, occ, virt, occ}) ||
             isSpacePattern(indices, {virt, virt, virt, occ})) {
    // Exchange second and third index
    return Tensor(L"J", {indices[0], indices[2]}, {indices[1], indices[3]});
  } else {
    throw std::runtime_error("Unrecognized index space pattern on g-tensor");
  }
}

std::wstring to_itf(const Index& idx) {
  // The labels are of the form <letter>_<number> and we want <number>
  // Note that SeQuant uses 1-based indexing, but we want 0-based
  int num =
      std::stoi(std::wstring(idx.label().substr(idx.label().find('_') + 1))) -
      1;
  assert(num >= 0 && num <= 6);

  if (idx.space().type() == IndexSpace::active_occupied) {
    return std::vector<std::wstring>{L"i", L"j", L"k", L"l", L"m", L"n"}.at(
        num);
  } else if (idx.space().type() == IndexSpace::active_unoccupied) {
    return std::vector<std::wstring>{L"a", L"b", L"c", L"d", L"e", L"f"}.at(
        num);
  }

  throw std::runtime_error("Unexpected index space");
}

std::wstring to_itf(const Tensor& tensor) {
  if (tensor.label() == L"g") {
    // g needs to be mapped to either K or J
    return to_itf(transform_two_electron_ints(tensor));
  }

  std::wstring spaceTag;
  std::wstring itf = L"[";
  for (const Index& current : tensor.braket()) {
    itf += to_itf(current);
    spaceTag += to_itf_tag(current.space());
  }
  itf += L"]";

  itf = std::wstring(tensor.label()) +
        (spaceTag.empty() ? L"" : L":" + spaceTag) + itf;

  return itf;
}

struct ProductHasher {
  std::size_t operator()(const Product& prod) const { return hash_value(prod); }
};

std::wstring to_itf(const Product& product, const Tensor& result) {
  static std::size_t intermediateCounter = 1;

  std::wstring itf;
  std::unordered_map<Product, Tensor, ProductHasher> intermediates;

  // 1. Handle nested multiplications (yielding an intermediate)
  for (const ExprPtr& currentFactor : product) {
    if (currentFactor->is<Product>()) {
      BraKetIndices externals = determine_result_indices(currentFactor);
      Tensor intermediate(
          std::wstring(L"STIN") + std::to_wstring(intermediateCounter++),
          externals.bra, externals.ket);
      std::wstring intermediateDef =
          to_itf(currentFactor->as<Product>(), intermediate);

      itf += intermediateDef;

      intermediates.insert(
          {currentFactor->as<Product>(), std::move(intermediate)});
    }
  }

  using sequant::to_wstring;

  // Now use the intermediates to write down the remaining part
  std::wstring productItf;
  for (const ExprPtr& currentFactor : product) {
    if (currentFactor->is<Product>()) {
      productItf +=
          to_itf(intermediates.at(currentFactor->as<Product>())) + L" ";
    } else if (currentFactor->is<Tensor>()) {
      productItf += to_itf(currentFactor->as<Tensor>()) + L" ";
    } else if (currentFactor->is<Constant>()) {
      throw std::runtime_error(
          "Expected constant factor to be a property of the Product object");
    }
  }

  assert(product.scalar().imag().is_zero());
  auto factor = product.scalar().real();
  bool isNegative = false;
  if (factor < 0) {
    factor *= -1;
    isNegative = true;
  }

  itf += L"." + to_itf(result) + (isNegative ? L" -= " : L" += ") +
         (factor != 1 ? to_wstring(factor) + L" * " : L"") + productItf + L"\n";

  return itf;
}

std::wstring to_itf(const ExprPtr& expr, const Tensor& result) {
  std::wstring itfCode;

  ExprPtr expandedExpr = expr;
  expandedExpr = expand(expandedExpr);

  for (const ExprPtr& currentAddend : expandedExpr->as<Sum>()) {
    if (currentAddend->is<Tensor>()) {
      itfCode += to_itf(result) + L" += " +
                 to_itf(currentAddend->as<Tensor>()) + L"\n";
    } else if (currentAddend->is<Product>()) {
      itfCode += to_itf(currentAddend->as<Product>(), result);
    } else {
      throw std::runtime_error("Unhandled case");
    }
  }

  return itfCode;
}

ExprPtr T(const std::vector<std::size_t>& projectionManifold) {
  auto T = std::make_shared<Sum>();
  for (std::size_t current : projectionManifold) {
    if (current == 0) {
      continue;
    }

    T->append(op::T_(current));
  }

  return T;
}

int main(int argc, const char** argv) {
  sequant::detail::OpIdRegistrar op_id_registrar;
  sequant::set_default_context(
      Context(Vacuum::SingleProduct, IndexSpaceMetric::Unit,
              BraKetSymmetry::conjugate, SPBasis::spinorbital));
  mbpt::set_default_convention();
  TensorCanonicalizer::register_instance(
      std::make_shared<DefaultTensorCanonicalizer>());

  std::size_t maxExcitation = 2;
  bool includeSingles = false;

  std::vector<std::size_t> projectionManifold(maxExcitation + 1);
  std::iota(projectionManifold.begin(), projectionManifold.end(), 0);
  if (!includeSingles && maxExcitation > 1) {
    projectionManifold.erase(projectionManifold.begin() + 1);
  }

  std::wcout << L"Chosen projection manifold is ";
  for (std::size_t currentProjection : projectionManifold) {
    std::wcout << L"<" << std::to_wstring(currentProjection) << "|, ";
  }
  std::wcout << "\n\n";

  // 1. Construct Hbar
  ExprPtr hbar = op::H();
  ExprPtr H_Tk = hbar;
  for (int64_t k = 1; k <= 4; ++k) {
    H_Tk =
        simplify(ex<Constant>(rational{1, k}) * H_Tk * T(projectionManifold));
    hbar += H_Tk;
  }

  std::wcout << L"Hbar:\n" << to_latex_align(hbar) << "\n\n";

  // 2. project onto doubles manifold, screen, lower to tensor form and wick it
  std::vector<ExprPtr> equations;

  for (std::size_t p : projectionManifold) {
    // 2.a. screen out terms that cannot give nonzero after projection onto
    // <p|
    std::shared_ptr<Sum> screendedTerms;

    for (const ExprPtr& term : *hbar) {
      assert(term->is<Product>() || term->is<op_t>());

      if (op::raises_vacuum_to_rank(term, p)) {
        if (!screendedTerms) {
          screendedTerms = std::make_shared<Sum>(ExprPtrList{term});
        } else {
          screendedTerms->append(term);
        }
      }
    }

    if (p > 0) {
      // 2.b project onto <p|, i.e. multiply by P(p)
      ExprPtr P_hbar = simplify(op::P(p) * screendedTerms);

      // 2.c compute vacuum expectation value (Wick theorem)
      equations.push_back(op::vac_av(P_hbar));
    } else {
      // Use equation as-is (no projection required)
      equations.push_back(op::vac_av(screendedTerms));
    }

    simplify(equations.back());
  }

  for (std::size_t i = 0; i < projectionManifold.size(); ++i) {
    std::size_t currentProjection = projectionManifold.at(i);
    std::wcout << L"Equations for projection on <" << currentProjection
               << L"|:\n=============================\nRaw ("
               << equations[i]->size() << L"):\n"
               << to_latex_align(equations.at(i)) << "\n\n";

    // Spintrace
    equations[i] =
        simplify(closed_shell_CC_spintrace(equations[i], currentProjection));

    std::wcout << L"Spin-traced (" << equations[i]->size() << L"):\n"
               << to_latex_align(equations.at(i)) << "\n\n";

    // Remove symmetrization operator as this is not a tensor (but the optimize
    // function would treat it as such)
    // -> from here on the final symmetrization is implicit!
    equations[i] = remove_tensor(equations[i], L"S");

    // Optimize
    equations[i] = optimize(equations[i], Idx2Size{});

    std::wcout << L"Optimized (" << equations[i]->size() << L"):\n"
               << to_latex_align(equations[i]) << "\n\n";

    BraKetIndices externals = determine_result_indices(equations[i]);
    std::wstring resultName = [&]() -> std::wstring {
      if (currentProjection == 0) {
        return L"E";
      }
      return L"R" + std::to_wstring(currentProjection) +
             (currentProjection > 1 ? L"u" : L"");
    }();
    Tensor resultTensor(resultName, externals.bra, externals.ket);

    std::wcout << L"ITF code:\n"
               << to_itf(equations[i], resultTensor) << L"\n\n\n";
  }
}
