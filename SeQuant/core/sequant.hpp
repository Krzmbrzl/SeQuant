#ifndef SEQUANT_SEQUANT_H
#define SEQUANT_SEQUANT_H

#include "attr.hpp"
#include "index.hpp"
#include "space.hpp"

#include <optional>

namespace sequant {

/// Specifies second quantization context, such as vacuum choice, whether index
/// spaces are orthonormal, sizes of index spaces, etc.
class SeQuant {
 public:
  struct Defaults {
    constexpr static auto vacuum = Vacuum::Physical;
    constexpr static auto metric = IndexSpaceMetric::Unit;
    constexpr static auto braket_symmetry = BraKetSymmetry::conjugate;
    constexpr static auto spbasis = sequant::SPBasis::spinorbital;
    constexpr static auto first_dummy_index_ordinal = 100;

    constexpr static auto csv_formalism = CSVFormalism::NonCSV;
    constexpr static auto sum_over_uocc_ = SumOverUocc::Truncated;
  };

  /// @param vac a Vacuum object
  /// @param m an IndexSpaceMetric object
  /// @param bks a BraKetSymmetry object
  /// @param spb single-particle basis (spin-free or spin-dependent)
  /// @param fdio first dummy index ordinal
  explicit SeQuant(Vacuum vac, IndexSpaceMetric m = Defaults::metric,
                   BraKetSymmetry bks = Defaults::braket_symmetry,
                   SPBasis spb = Defaults::spbasis,
                   std::size_t fdio = Defaults::first_dummy_index_ordinal);

  /// default constructor, equivalent to SeQuant(Vacuum::Physical,
  /// IndexSpaceMetric::Unit, BraKetSymmetry::conjugate,
  /// sequant::SPBasis::spinorbital, 100)
  SeQuant() = default;

  ~SeQuant() = default;

  SeQuant(const SeQuant&) = default;
  SeQuant& operator=(const SeQuant&) = default;

  /// \return Vacuum of this context
  Vacuum vacuum() const;
  /// \return IndexSpaceMetric of this context
  IndexSpaceMetric metric() const;
  /// \return BraKetSymmetry of this context
  BraKetSymmetry braket_symmetry() const;
  /// \return SPBasis of this context
  SPBasis spbasis() const;
  /// \return first ordinal of the dummy indices generated by calls to
  /// Index::next_tmp_index when this context is active
  std::size_t first_dummy_index_ordinal() const;

  ///
  /// \return the two-body interactions treatment by operator: ie whether
  ///         they are antisymmetric or not. It is antisymmetric for
  ///         non-physical vacua
  ///
  TwoBodyInteraction two_body_interaction() const;

  /// \return whether the formalism is to sum over complete unoccupieds or
  ///         their truncation.
  SumOverUocc sum_over_uocc() const;

  /// \return whether to use cluster-specific-virtuals formalism or not.
  CSVFormalism csv_formalism() const;



  /// Sets the Vacuum for this context, convenient for chaining
  /// \param vacuum Vacuum
  /// \return ref to `*this`, for chaining
  SeQuant& set(Vacuum vacuum);
  /// Sets the IndexSpaceMetric for this context, convenient for chaining
  /// \param metric IndexSpaceMetric
  /// \return ref to `*this`, for chaining
  SeQuant& set(IndexSpaceMetric metric);
  /// Sets the BraKetSymmetry for this context, convenient for chaining
  /// \param braket_symmetry BraKetSymmetry
  /// \return ref to `*this`, for chaining
  SeQuant& set(BraKetSymmetry braket_symmetry);
  /// Sets the SPBasis for this context, convenient for chaining
  /// \param spbasis SPBasis
  /// \return ref to `*this`, for chaining
  SeQuant& set(SPBasis spbasis);
  /// Sets the first dummy index ordinal for this context, convenient for
  /// chaining \param first_dummy_index_ordinal the first dummy index ordinal
  /// \return ref to `*this`, for chaining
  SeQuant& set_first_dummy_index_ordinal(std::size_t first_dummy_index_ordinal);

  SeQuant& set(SumOverUocc sou);

  SeQuant& set(CSVFormalism csvf);

  /// @return the IndexRegistry object
  std::shared_ptr<IndexRegistry> index_registry() const;

 private:
  Vacuum vacuum_ = Defaults::vacuum;
  IndexSpaceMetric metric_ = Defaults::metric;
  BraKetSymmetry braket_symmetry_ = Defaults::braket_symmetry;
  SPBasis spbasis_ = Defaults::spbasis;
  std::size_t first_dummy_index_ordinal_ = Defaults::first_dummy_index_ordinal;
  SumOverUocc sum_over_uocc_ = Defaults::sum_over_uocc_;
  CSVFormalism csv_formalism_ = Defaults::csv_formalism;
  TwoBodyInteraction two_body_interaction_ = TwoBodyInteraction::Antisymm;
};

/// SeQuant object equality comparison
/// \param ctx1
/// \param ctx2
/// \return true if \p ctx1 and \p ctx2 are equal
/// \warning does not compare index registries
bool operator==(const SeQuant& ctx1, const SeQuant& ctx2);

/// SeQuant object inequality comparison
/// \param ctx1
/// \param ctx2
/// \return true if \p ctx1 and \p ctx2 are not equal
/// \warning does not compare index registries
bool operator!=(const SeQuant& ctx1, const SeQuant& ctx2);

const SeQuant& get_default_context();
void set_default_context(const SeQuant& ctx);
void reset_default_context();

namespace detail {
struct ContextResetter {
  ContextResetter() = default;
  ContextResetter(const SeQuant& previous_ctx) noexcept;
  ~ContextResetter() noexcept;

  // ContextResetter is move-only
  ContextResetter(const ContextResetter&) = delete;
  ContextResetter& operator=(const ContextResetter&) = delete;

 private:
  std::optional<SeQuant> previous_ctx_;
};
}  // namespace detail

detail::ContextResetter set_scoped_default_context(const SeQuant& ctx);

}  // namespace sequant

#endif
